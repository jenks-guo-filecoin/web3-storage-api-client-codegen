/*
 * Web3.Storage API
 *
 * This documentation describes the HTTP API for [**Web3.Storage**](https://web3.storage), which allows you to quickly and easily build applications using decentralized data storage persisted by [Filecoin](https://filecoin.io) and available over [IPFS](https://ipfs.io).  You can also interact with this API using client libraries. See [**docs.web3.storage**](https://docs.web3.storage) for more information on using a client library, as well as a variety of other guides and how-tos for Web3.Storage as a whole.  ## API endpoint URL  The main public API endpoint URL for Web3.Storage is `https://api.web3.storage`. All endpoints described in this document should be made relative to this root URL. For example, to post to the `/car` endpoint, send your request to `https://api.web3.storage/car`.  ### Rate limits  This API imposes rate limits to ensure quality of service. You may receive a 429 \"Too many requests\" error if you make more than 30 requests with the same API token within a ten second window. Upon receiving a response with a 429 status, clients should retry the failed request after a small delay. To avoid 429 responses, you may wish to implement client-side request throttling to stay within the limits. 
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Web3.Storage.Client;
using Web3.Storage.Model;

namespace Web3.Storage.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWeb3StorageHTTPAPIApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Remove pin object
        /// </summary>
        /// <remarks>
        /// Remove a pin object
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns></returns>
        void DeletePinsRequestid(string requestid);

        /// <summary>
        /// Remove pin object
        /// </summary>
        /// <remarks>
        /// Remove a pin object
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeletePinsRequestidWithHttpInfo(string requestid);
        /// <summary>
        /// Retrieve a CAR
        /// </summary>
        /// <remarks>
        /// Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>System.IO.Stream</returns>
        System.IO.Stream GetCarCid(string cid);

        /// <summary>
        /// Retrieve a CAR
        /// </summary>
        /// <remarks>
        /// Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        ApiResponse<System.IO.Stream> GetCarCidWithHttpInfo(string cid);
        /// <summary>
        /// List pin objects
        /// </summary>
        /// <remarks>
        /// List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <returns>PinResults</returns>
        PinResults GetPins(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>));

        /// <summary>
        /// List pin objects
        /// </summary>
        /// <remarks>
        /// List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <returns>ApiResponse of PinResults</returns>
        ApiResponse<PinResults> GetPinsWithHttpInfo(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>));
        /// <summary>
        /// Get pin object
        /// </summary>
        /// <remarks>
        /// Get a pin object and its status
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns>PinStatus</returns>
        PinStatus GetPinsRequestid(string requestid);

        /// <summary>
        /// Get pin object
        /// </summary>
        /// <remarks>
        /// Get a pin object and its status
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns>ApiResponse of PinStatus</returns>
        ApiResponse<PinStatus> GetPinsRequestidWithHttpInfo(string requestid);
        /// <summary>
        /// Retrieve information about an upload
        /// </summary>
        /// <remarks>
        /// Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>Status</returns>
        Status GetStatusCid(string cid);

        /// <summary>
        /// Retrieve information about an upload
        /// </summary>
        /// <remarks>
        /// Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>ApiResponse of Status</returns>
        ApiResponse<Status> GetStatusCidWithHttpInfo(string cid);
        /// <summary>
        /// List previous uploads
        /// </summary>
        /// <remarks>
        /// Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <returns>List&lt;Status&gt;</returns>
        List<Status> GetUserUploads(DateTime? before = default(DateTime?), int? size = default(int?));

        /// <summary>
        /// List previous uploads
        /// </summary>
        /// <remarks>
        /// Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <returns>ApiResponse of List&lt;Status&gt;</returns>
        ApiResponse<List<Status>> GetUserUploadsWithHttpInfo(DateTime? before = default(DateTime?), int? size = default(int?));
        /// <summary>
        /// Retrieve HTTP headers regarding a CAR
        /// </summary>
        /// <remarks>
        /// This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns></returns>
        void HeadCarCid(string cid);

        /// <summary>
        /// Retrieve HTTP headers regarding a CAR
        /// </summary>
        /// <remarks>
        /// This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> HeadCarCidWithHttpInfo(string cid);
        /// <summary>
        /// Upload a CAR
        /// </summary>
        /// <remarks>
        /// Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <returns>UploadResponse</returns>
        UploadResponse PostCar(System.IO.Stream body);

        /// <summary>
        /// Upload a CAR
        /// </summary>
        /// <remarks>
        /// Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <returns>ApiResponse of UploadResponse</returns>
        ApiResponse<UploadResponse> PostCarWithHttpInfo(System.IO.Stream body);
        /// <summary>
        /// Add pin object
        /// </summary>
        /// <remarks>
        /// Add a new pin object for the current access token
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <returns>PinStatus</returns>
        PinStatus PostPins(PSAPin pSAPin);

        /// <summary>
        /// Add pin object
        /// </summary>
        /// <remarks>
        /// Add a new pin object for the current access token
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <returns>ApiResponse of PinStatus</returns>
        ApiResponse<PinStatus> PostPinsWithHttpInfo(PSAPin pSAPin);
        /// <summary>
        /// Replace pin object
        /// </summary>
        /// <remarks>
        /// Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <returns>PinStatus</returns>
        PinStatus PostPinsRequestid(string requestid, PSAPin pSAPin);

        /// <summary>
        /// Replace pin object
        /// </summary>
        /// <remarks>
        /// Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <returns>ApiResponse of PinStatus</returns>
        ApiResponse<PinStatus> PostPinsRequestidWithHttpInfo(string requestid, PSAPin pSAPin);
        /// <summary>
        /// Upload and store one or more files
        /// </summary>
        /// <remarks>
        /// Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <returns>UploadResponse</returns>
        UploadResponse PostUpload(List<System.IO.Stream> file = default(List<System.IO.Stream>));

        /// <summary>
        /// Upload and store one or more files
        /// </summary>
        /// <remarks>
        /// Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <returns>ApiResponse of UploadResponse</returns>
        ApiResponse<UploadResponse> PostUploadWithHttpInfo(List<System.IO.Stream> file = default(List<System.IO.Stream>));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWeb3StorageHTTPAPIApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Remove pin object
        /// </summary>
        /// <remarks>
        /// Remove a pin object
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeletePinsRequestidAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Remove pin object
        /// </summary>
        /// <remarks>
        /// Remove a pin object
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeletePinsRequestidWithHttpInfoAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a CAR
        /// </summary>
        /// <remarks>
        /// Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        System.Threading.Tasks.Task<System.IO.Stream> GetCarCidAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a CAR
        /// </summary>
        /// <remarks>
        /// Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        System.Threading.Tasks.Task<ApiResponse<System.IO.Stream>> GetCarCidWithHttpInfoAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List pin objects
        /// </summary>
        /// <remarks>
        /// List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinResults</returns>
        System.Threading.Tasks.Task<PinResults> GetPinsAsync(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List pin objects
        /// </summary>
        /// <remarks>
        /// List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinResults)</returns>
        System.Threading.Tasks.Task<ApiResponse<PinResults>> GetPinsWithHttpInfoAsync(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get pin object
        /// </summary>
        /// <remarks>
        /// Get a pin object and its status
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinStatus</returns>
        System.Threading.Tasks.Task<PinStatus> GetPinsRequestidAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get pin object
        /// </summary>
        /// <remarks>
        /// Get a pin object and its status
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<PinStatus>> GetPinsRequestidWithHttpInfoAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve information about an upload
        /// </summary>
        /// <remarks>
        /// Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Status</returns>
        System.Threading.Tasks.Task<Status> GetStatusCidAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve information about an upload
        /// </summary>
        /// <remarks>
        /// Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<Status>> GetStatusCidWithHttpInfoAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List previous uploads
        /// </summary>
        /// <remarks>
        /// Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Status&gt;</returns>
        System.Threading.Tasks.Task<List<Status>> GetUserUploadsAsync(DateTime? before = default(DateTime?), int? size = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List previous uploads
        /// </summary>
        /// <remarks>
        /// Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Status&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Status>>> GetUserUploadsWithHttpInfoAsync(DateTime? before = default(DateTime?), int? size = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve HTTP headers regarding a CAR
        /// </summary>
        /// <remarks>
        /// This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task HeadCarCidAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve HTTP headers regarding a CAR
        /// </summary>
        /// <remarks>
        /// This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> HeadCarCidWithHttpInfoAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Upload a CAR
        /// </summary>
        /// <remarks>
        /// Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadResponse</returns>
        System.Threading.Tasks.Task<UploadResponse> PostCarAsync(System.IO.Stream body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Upload a CAR
        /// </summary>
        /// <remarks>
        /// Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<UploadResponse>> PostCarWithHttpInfoAsync(System.IO.Stream body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add pin object
        /// </summary>
        /// <remarks>
        /// Add a new pin object for the current access token
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinStatus</returns>
        System.Threading.Tasks.Task<PinStatus> PostPinsAsync(PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Add pin object
        /// </summary>
        /// <remarks>
        /// Add a new pin object for the current access token
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<PinStatus>> PostPinsWithHttpInfoAsync(PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Replace pin object
        /// </summary>
        /// <remarks>
        /// Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinStatus</returns>
        System.Threading.Tasks.Task<PinStatus> PostPinsRequestidAsync(string requestid, PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Replace pin object
        /// </summary>
        /// <remarks>
        /// Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<PinStatus>> PostPinsRequestidWithHttpInfoAsync(string requestid, PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Upload and store one or more files
        /// </summary>
        /// <remarks>
        /// Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadResponse</returns>
        System.Threading.Tasks.Task<UploadResponse> PostUploadAsync(List<System.IO.Stream> file = default(List<System.IO.Stream>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Upload and store one or more files
        /// </summary>
        /// <remarks>
        /// Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </remarks>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<UploadResponse>> PostUploadWithHttpInfoAsync(List<System.IO.Stream> file = default(List<System.IO.Stream>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWeb3StorageHTTPAPIApi : IWeb3StorageHTTPAPIApiSync, IWeb3StorageHTTPAPIApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class Web3StorageHTTPAPIApi : IWeb3StorageHTTPAPIApi
    {
        private Web3.Storage.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="Web3StorageHTTPAPIApi"/> class.
        /// </summary>
        /// <returns></returns>
        public Web3StorageHTTPAPIApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Web3StorageHTTPAPIApi"/> class.
        /// </summary>
        /// <returns></returns>
        public Web3StorageHTTPAPIApi(string basePath)
        {
            this.Configuration = Web3.Storage.Client.Configuration.MergeConfigurations(
                Web3.Storage.Client.GlobalConfiguration.Instance,
                new Web3.Storage.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Web3.Storage.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Web3.Storage.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Web3.Storage.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Web3StorageHTTPAPIApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public Web3StorageHTTPAPIApi(Web3.Storage.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Web3.Storage.Client.Configuration.MergeConfigurations(
                Web3.Storage.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Web3.Storage.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Web3.Storage.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Web3.Storage.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Web3StorageHTTPAPIApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public Web3StorageHTTPAPIApi(Web3.Storage.Client.ISynchronousClient client, Web3.Storage.Client.IAsynchronousClient asyncClient, Web3.Storage.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Web3.Storage.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Web3.Storage.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Web3.Storage.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Web3.Storage.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Web3.Storage.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Remove pin object Remove a pin object
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns></returns>
        public void DeletePinsRequestid(string requestid)
        {
            DeletePinsRequestidWithHttpInfo(requestid);
        }

        /// <summary>
        /// Remove pin object Remove a pin object
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Web3.Storage.Client.ApiResponse<Object> DeletePinsRequestidWithHttpInfo(string requestid)
        {
            // verify the required parameter 'requestid' is set
            if (requestid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'requestid' when calling Web3StorageHTTPAPIApi->DeletePinsRequestid");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("requestid", Web3.Storage.Client.ClientUtils.ParameterToString(requestid)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/pins/{requestid}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePinsRequestid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Remove pin object Remove a pin object
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeletePinsRequestidAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeletePinsRequestidWithHttpInfoAsync(requestid, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Remove pin object Remove a pin object
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<Object>> DeletePinsRequestidWithHttpInfoAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'requestid' is set
            if (requestid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'requestid' when calling Web3StorageHTTPAPIApi->DeletePinsRequestid");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("requestid", Web3.Storage.Client.ClientUtils.ParameterToString(requestid)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/pins/{requestid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeletePinsRequestid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a CAR Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>System.IO.Stream</returns>
        public System.IO.Stream GetCarCid(string cid)
        {
            Web3.Storage.Client.ApiResponse<System.IO.Stream> localVarResponse = GetCarCidWithHttpInfo(cid);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a CAR Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>ApiResponse of System.IO.Stream</returns>
        public Web3.Storage.Client.ApiResponse<System.IO.Stream> GetCarCidWithHttpInfo(string cid)
        {
            // verify the required parameter 'cid' is set
            if (cid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'cid' when calling Web3StorageHTTPAPIApi->GetCarCid");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/car",
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("cid", Web3.Storage.Client.ClientUtils.ParameterToString(cid)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<System.IO.Stream>("/car/{cid}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCarCid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a CAR Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of System.IO.Stream</returns>
        public async System.Threading.Tasks.Task<System.IO.Stream> GetCarCidAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<System.IO.Stream> localVarResponse = await GetCarCidWithHttpInfoAsync(cid, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a CAR Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<System.IO.Stream>> GetCarCidWithHttpInfoAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'cid' is set
            if (cid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'cid' when calling Web3StorageHTTPAPIApi->GetCarCid");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/car",
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("cid", Web3.Storage.Client.ClientUtils.ParameterToString(cid)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<System.IO.Stream>("/car/{cid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCarCid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List pin objects List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <returns>PinResults</returns>
        public PinResults GetPins(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>))
        {
            Web3.Storage.Client.ApiResponse<PinResults> localVarResponse = GetPinsWithHttpInfo(cid, name, match, status, before, after, limit, meta);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List pin objects List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <returns>ApiResponse of PinResults</returns>
        public Web3.Storage.Client.ApiResponse<PinResults> GetPinsWithHttpInfo(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>))
        {
            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (cid != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("csv", "cid", cid));
            }
            if (name != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "name", name));
            }
            if (match != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "match", match));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("csv", "status", status));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (after != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "after", after));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (meta != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "meta", meta));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PinResults>("/pins", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPins", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List pin objects List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinResults</returns>
        public async System.Threading.Tasks.Task<PinResults> GetPinsAsync(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<PinResults> localVarResponse = await GetPinsWithHttpInfoAsync(cid, name, match, status, before, after, limit, meta, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List pin objects List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid">Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts (optional)</param>
        /// <param name="name">Return pin objects with specified name (by default a case-sensitive, exact match) (optional)</param>
        /// <param name="match">Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (optional)</param>
        /// <param name="status">Return pin objects for pins with the specified status (optional)</param>
        /// <param name="before">Return results created (queued) before provided timestamp (optional)</param>
        /// <param name="after">Return results created (queued) after provided timestamp (optional)</param>
        /// <param name="limit">Max records to return (optional, default to 10)</param>
        /// <param name="meta">Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinResults)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<PinResults>> GetPinsWithHttpInfoAsync(List<string> cid = default(List<string>), string name = default(string), TextMatchingStrategy? match = default(TextMatchingStrategy?), List<string> status = default(List<string>), DateTime? before = default(DateTime?), DateTime? after = default(DateTime?), int? limit = default(int?), Dictionary<string, string> meta = default(Dictionary<string, string>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (cid != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("csv", "cid", cid));
            }
            if (name != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "name", name));
            }
            if (match != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "match", match));
            }
            if (status != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("csv", "status", status));
            }
            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (after != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "after", after));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (meta != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "meta", meta));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<PinResults>("/pins", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPins", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get pin object Get a pin object and its status
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns>PinStatus</returns>
        public PinStatus GetPinsRequestid(string requestid)
        {
            Web3.Storage.Client.ApiResponse<PinStatus> localVarResponse = GetPinsRequestidWithHttpInfo(requestid);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get pin object Get a pin object and its status
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <returns>ApiResponse of PinStatus</returns>
        public Web3.Storage.Client.ApiResponse<PinStatus> GetPinsRequestidWithHttpInfo(string requestid)
        {
            // verify the required parameter 'requestid' is set
            if (requestid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'requestid' when calling Web3StorageHTTPAPIApi->GetPinsRequestid");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("requestid", Web3.Storage.Client.ClientUtils.ParameterToString(requestid)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PinStatus>("/pins/{requestid}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPinsRequestid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get pin object Get a pin object and its status
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinStatus</returns>
        public async System.Threading.Tasks.Task<PinStatus> GetPinsRequestidAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<PinStatus> localVarResponse = await GetPinsRequestidWithHttpInfoAsync(requestid, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get pin object Get a pin object and its status
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinStatus)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<PinStatus>> GetPinsRequestidWithHttpInfoAsync(string requestid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'requestid' is set
            if (requestid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'requestid' when calling Web3StorageHTTPAPIApi->GetPinsRequestid");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("requestid", Web3.Storage.Client.ClientUtils.ParameterToString(requestid)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<PinStatus>("/pins/{requestid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPinsRequestid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve information about an upload Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>Status</returns>
        public Status GetStatusCid(string cid)
        {
            Web3.Storage.Client.ApiResponse<Status> localVarResponse = GetStatusCidWithHttpInfo(cid);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve information about an upload Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>ApiResponse of Status</returns>
        public Web3.Storage.Client.ApiResponse<Status> GetStatusCidWithHttpInfo(string cid)
        {
            // verify the required parameter 'cid' is set
            if (cid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'cid' when calling Web3StorageHTTPAPIApi->GetStatusCid");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("cid", Web3.Storage.Client.ClientUtils.ParameterToString(cid)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<Status>("/status/{cid}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetStatusCid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve information about an upload Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Status</returns>
        public async System.Threading.Tasks.Task<Status> GetStatusCidAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<Status> localVarResponse = await GetStatusCidWithHttpInfoAsync(cid, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve information about an upload Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Status)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<Status>> GetStatusCidWithHttpInfoAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'cid' is set
            if (cid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'cid' when calling Web3StorageHTTPAPIApi->GetStatusCid");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("cid", Web3.Storage.Client.ClientUtils.ParameterToString(cid)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Status>("/status/{cid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetStatusCid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List previous uploads Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <returns>List&lt;Status&gt;</returns>
        public List<Status> GetUserUploads(DateTime? before = default(DateTime?), int? size = default(int?))
        {
            Web3.Storage.Client.ApiResponse<List<Status>> localVarResponse = GetUserUploadsWithHttpInfo(before, size);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List previous uploads Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <returns>ApiResponse of List&lt;Status&gt;</returns>
        public Web3.Storage.Client.ApiResponse<List<Status>> GetUserUploadsWithHttpInfo(DateTime? before = default(DateTime?), int? size = default(int?))
        {
            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Status>>("/user/uploads", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUserUploads", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List previous uploads Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Status&gt;</returns>
        public async System.Threading.Tasks.Task<List<Status>> GetUserUploadsAsync(DateTime? before = default(DateTime?), int? size = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<List<Status>> localVarResponse = await GetUserUploadsWithHttpInfoAsync(before, size, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List previous uploads Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="before">Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date. (optional)</param>
        /// <param name="size">Specifies the maximum number of uploads to return. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Status&gt;)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<List<Status>>> GetUserUploadsWithHttpInfoAsync(DateTime? before = default(DateTime?), int? size = default(int?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (before != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "before", before));
            }
            if (size != null)
            {
                localVarRequestOptions.QueryParameters.Add(Web3.Storage.Client.ClientUtils.ParameterToMultiMap("", "size", size));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Status>>("/user/uploads", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetUserUploads", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve HTTP headers regarding a CAR This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns></returns>
        public void HeadCarCid(string cid)
        {
            HeadCarCidWithHttpInfo(cid);
        }

        /// <summary>
        /// Retrieve HTTP headers regarding a CAR This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Web3.Storage.Client.ApiResponse<Object> HeadCarCidWithHttpInfo(string cid)
        {
            // verify the required parameter 'cid' is set
            if (cid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'cid' when calling Web3StorageHTTPAPIApi->HeadCarCid");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("cid", Web3.Storage.Client.ClientUtils.ParameterToString(cid)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Head<Object>("/car/{cid}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("HeadCarCid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve HTTP headers regarding a CAR This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task HeadCarCidAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await HeadCarCidWithHttpInfoAsync(cid, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Retrieve HTTP headers regarding a CAR This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cid"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<Object>> HeadCarCidWithHttpInfoAsync(string cid, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'cid' is set
            if (cid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'cid' when calling Web3StorageHTTPAPIApi->HeadCarCid");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("cid", Web3.Storage.Client.ClientUtils.ParameterToString(cid)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.HeadAsync<Object>("/car/{cid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("HeadCarCid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload a CAR Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <returns>UploadResponse</returns>
        public UploadResponse PostCar(System.IO.Stream body)
        {
            Web3.Storage.Client.ApiResponse<UploadResponse> localVarResponse = PostCarWithHttpInfo(body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload a CAR Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <returns>ApiResponse of UploadResponse</returns>
        public Web3.Storage.Client.ApiResponse<UploadResponse> PostCarWithHttpInfo(System.IO.Stream body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'body' when calling Web3StorageHTTPAPIApi->PostCar");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/car",
                "application/octet-stream"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = body;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UploadResponse>("/car", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostCar", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload a CAR Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadResponse</returns>
        public async System.Threading.Tasks.Task<UploadResponse> PostCarAsync(System.IO.Stream body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<UploadResponse> localVarResponse = await PostCarWithHttpInfoAsync(body, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload a CAR Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadResponse)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<UploadResponse>> PostCarWithHttpInfoAsync(System.IO.Stream body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'body' when calling Web3StorageHTTPAPIApi->PostCar");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/car", 
                "application/octet-stream"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = body;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<UploadResponse>("/car", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostCar", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add pin object Add a new pin object for the current access token
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <returns>PinStatus</returns>
        public PinStatus PostPins(PSAPin pSAPin)
        {
            Web3.Storage.Client.ApiResponse<PinStatus> localVarResponse = PostPinsWithHttpInfo(pSAPin);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Add pin object Add a new pin object for the current access token
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <returns>ApiResponse of PinStatus</returns>
        public Web3.Storage.Client.ApiResponse<PinStatus> PostPinsWithHttpInfo(PSAPin pSAPin)
        {
            // verify the required parameter 'pSAPin' is set
            if (pSAPin == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'pSAPin' when calling Web3StorageHTTPAPIApi->PostPins");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = pSAPin;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PinStatus>("/pins", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostPins", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Add pin object Add a new pin object for the current access token
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinStatus</returns>
        public async System.Threading.Tasks.Task<PinStatus> PostPinsAsync(PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<PinStatus> localVarResponse = await PostPinsWithHttpInfoAsync(pSAPin, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Add pin object Add a new pin object for the current access token
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinStatus)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<PinStatus>> PostPinsWithHttpInfoAsync(PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'pSAPin' is set
            if (pSAPin == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'pSAPin' when calling Web3StorageHTTPAPIApi->PostPins");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = pSAPin;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<PinStatus>("/pins", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostPins", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Replace pin object Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <returns>PinStatus</returns>
        public PinStatus PostPinsRequestid(string requestid, PSAPin pSAPin)
        {
            Web3.Storage.Client.ApiResponse<PinStatus> localVarResponse = PostPinsRequestidWithHttpInfo(requestid, pSAPin);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Replace pin object Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <returns>ApiResponse of PinStatus</returns>
        public Web3.Storage.Client.ApiResponse<PinStatus> PostPinsRequestidWithHttpInfo(string requestid, PSAPin pSAPin)
        {
            // verify the required parameter 'requestid' is set
            if (requestid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'requestid' when calling Web3StorageHTTPAPIApi->PostPinsRequestid");

            // verify the required parameter 'pSAPin' is set
            if (pSAPin == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'pSAPin' when calling Web3StorageHTTPAPIApi->PostPinsRequestid");

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("requestid", Web3.Storage.Client.ClientUtils.ParameterToString(requestid)); // path parameter
            localVarRequestOptions.Data = pSAPin;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PinStatus>("/pins/{requestid}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostPinsRequestid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Replace pin object Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PinStatus</returns>
        public async System.Threading.Tasks.Task<PinStatus> PostPinsRequestidAsync(string requestid, PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<PinStatus> localVarResponse = await PostPinsRequestidWithHttpInfoAsync(requestid, pSAPin, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Replace pin object Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestid"></param>
        /// <param name="pSAPin"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PinStatus)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<PinStatus>> PostPinsRequestidWithHttpInfoAsync(string requestid, PSAPin pSAPin, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'requestid' is set
            if (requestid == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'requestid' when calling Web3StorageHTTPAPIApi->PostPinsRequestid");

            // verify the required parameter 'pSAPin' is set
            if (pSAPin == null)
                throw new Web3.Storage.Client.ApiException(400, "Missing required parameter 'pSAPin' when calling Web3StorageHTTPAPIApi->PostPinsRequestid");


            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("requestid", Web3.Storage.Client.ClientUtils.ParameterToString(requestid)); // path parameter
            localVarRequestOptions.Data = pSAPin;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<PinStatus>("/pins/{requestid}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostPinsRequestid", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload and store one or more files Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <returns>UploadResponse</returns>
        public UploadResponse PostUpload(List<System.IO.Stream> file = default(List<System.IO.Stream>))
        {
            Web3.Storage.Client.ApiResponse<UploadResponse> localVarResponse = PostUploadWithHttpInfo(file);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload and store one or more files Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <returns>ApiResponse of UploadResponse</returns>
        public Web3.Storage.Client.ApiResponse<UploadResponse> PostUploadWithHttpInfo(List<System.IO.Stream> file = default(List<System.IO.Stream>))
        {
            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (file != null)
            {
                localVarRequestOptions.FileParameters.Add("file", file);
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UploadResponse>("/upload", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostUpload", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Upload and store one or more files Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadResponse</returns>
        public async System.Threading.Tasks.Task<UploadResponse> PostUploadAsync(List<System.IO.Stream> file = default(List<System.IO.Stream>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Web3.Storage.Client.ApiResponse<UploadResponse> localVarResponse = await PostUploadWithHttpInfoAsync(file, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Upload and store one or more files Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
        /// </summary>
        /// <exception cref="Web3.Storage.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadResponse)</returns>
        public async System.Threading.Tasks.Task<Web3.Storage.Client.ApiResponse<UploadResponse>> PostUploadWithHttpInfoAsync(List<System.IO.Stream> file = default(List<System.IO.Stream>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Web3.Storage.Client.RequestOptions localVarRequestOptions = new Web3.Storage.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Web3.Storage.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Web3.Storage.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (file != null)
            {
                localVarRequestOptions.FileParameters.Add("file", file);
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<UploadResponse>("/upload", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("PostUpload", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
