=begin
#Web3.Storage API

#This documentation describes the HTTP API for [**Web3.Storage**](https://web3.storage), which allows you to quickly and easily build applications using decentralized data storage persisted by [Filecoin](https://filecoin.io) and available over [IPFS](https://ipfs.io).  You can also interact with this API using client libraries. See [**docs.web3.storage**](https://docs.web3.storage) for more information on using a client library, as well as a variety of other guides and how-tos for Web3.Storage as a whole.  ## API endpoint URL  The main public API endpoint URL for Web3.Storage is `https://api.web3.storage`. All endpoints described in this document should be made relative to this root URL. For example, to post to the `/car` endpoint, send your request to `https://api.web3.storage/car`.  ### Rate limits  This API imposes rate limits to ensure quality of service. You may receive a 429 \"Too many requests\" error if you make more than 30 requests with the same API token within a ten second window. Upon receiving a response with a 429 status, clients should retry the failed request after a small delay. To avoid 429 responses, you may wish to implement client-side request throttling to stay within the limits. 

The version of the OpenAPI document: 1.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.2.1

=end

require 'cgi'

module Web3Storage
  class Web3StorageHTTPAPIApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Remove pin object
    # Remove a pin object
    # @param requestid [String] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_pins_requestid(requestid, opts = {})
      delete_pins_requestid_with_http_info(requestid, opts)
      nil
    end

    # Remove pin object
    # Remove a pin object
    # @param requestid [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_pins_requestid_with_http_info(requestid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.delete_pins_requestid ...'
      end
      # verify the required parameter 'requestid' is set
      if @api_client.config.client_side_validation && requestid.nil?
        fail ArgumentError, "Missing the required parameter 'requestid' when calling Web3StorageHTTPAPIApi.delete_pins_requestid"
      end
      # resource path
      local_var_path = '/pins/{requestid}'.sub('{' + 'requestid' + '}', CGI.escape(requestid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.delete_pins_requestid",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#delete_pins_requestid\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a CAR
    # Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using `/car/{cid}`, supplying the CID of the data you are interested in.
    # @param cid [String] 
    # @param [Hash] opts the optional parameters
    # @return [File]
    def get_car_cid(cid, opts = {})
      data, _status_code, _headers = get_car_cid_with_http_info(cid, opts)
      data
    end

    # Retrieve a CAR
    # Retrieve an [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) packaged in a CAR file by using &#x60;/car/{cid}&#x60;, supplying the CID of the data you are interested in.
    # @param cid [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def get_car_cid_with_http_info(cid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.get_car_cid ...'
      end
      # verify the required parameter 'cid' is set
      if @api_client.config.client_side_validation && cid.nil?
        fail ArgumentError, "Missing the required parameter 'cid' when calling Web3StorageHTTPAPIApi.get_car_cid"
      end
      # resource path
      local_var_path = '/car/{cid}'.sub('{' + 'cid' + '}', CGI.escape(cid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/car', 'application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'File'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.get_car_cid",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#get_car_cid\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List pin objects
    # List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :cid Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
    # @option opts [String] :name Return pin objects with specified name (by default a case-sensitive, exact match)
    # @option opts [TextMatchingStrategy] :match Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies (default to 'exact')
    # @option opts [Array<String>] :status Return pin objects for pins with the specified status
    # @option opts [Time] :before Return results created (queued) before provided timestamp
    # @option opts [Time] :after Return results created (queued) after provided timestamp
    # @option opts [Integer] :limit Max records to return (default to 10)
    # @option opts [Hash<String, String>] :meta Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
    # @return [PinResults]
    def get_pins(opts = {})
      data, _status_code, _headers = get_pins_with_http_info(opts)
      data
    end

    # List pin objects
    # List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :cid Return pin objects responsible for pinning the specified CID(s); be aware that using longer hash functions introduces further constraints on the number of CIDs that will fit under the limit of 2000 characters per URL  in browser contexts
    # @option opts [String] :name Return pin objects with specified name (by default a case-sensitive, exact match)
    # @option opts [TextMatchingStrategy] :match Customize the text matching strategy applied when the name filter is present; exact (the default) is a case-sensitive exact match, partial matches anywhere in the name, iexact and ipartial are case-insensitive versions of the exact and partial strategies
    # @option opts [Array<String>] :status Return pin objects for pins with the specified status
    # @option opts [Time] :before Return results created (queued) before provided timestamp
    # @option opts [Time] :after Return results created (queued) after provided timestamp
    # @option opts [Integer] :limit Max records to return
    # @option opts [Hash<String, String>] :meta Return pin objects that match specified metadata keys passed as a string representation of a JSON object; when implementing a client library, make sure the parameter is URL-encoded to ensure safe transport
    # @return [Array<(PinResults, Integer, Hash)>] PinResults data, response status code and response headers
    def get_pins_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.get_pins ...'
      end
      if @api_client.config.client_side_validation && !opts[:'cid'].nil? && opts[:'cid'].length > 10
        fail ArgumentError, 'invalid value for "opts[:"cid"]" when calling Web3StorageHTTPAPIApi.get_pins, number of items must be less than or equal to 10.'
      end

      if @api_client.config.client_side_validation && !opts[:'cid'].nil? && opts[:'cid'].length < 1
        fail ArgumentError, 'invalid value for "opts[:"cid"]" when calling Web3StorageHTTPAPIApi.get_pins, number of items must be greater than or equal to 1.'
      end

      if @api_client.config.client_side_validation && !opts[:'name'].nil? && opts[:'name'].to_s.length > 255
        fail ArgumentError, 'invalid value for "opts[:"name"]" when calling Web3StorageHTTPAPIApi.get_pins, the character length must be smaller than or equal to 255.'
      end

      allowable_values = ["queued", "pinning", "pinned", "failed"]
      if @api_client.config.client_side_validation && opts[:'status'] && !opts[:'status'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"status\", must include one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling Web3StorageHTTPAPIApi.get_pins, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling Web3StorageHTTPAPIApi.get_pins, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/pins'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'cid'] = @api_client.build_collection_param(opts[:'cid'], :csv) if !opts[:'cid'].nil?
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'match'] = opts[:'match'] if !opts[:'match'].nil?
      query_params[:'status'] = @api_client.build_collection_param(opts[:'status'], :csv) if !opts[:'status'].nil?
      query_params[:'before'] = opts[:'before'] if !opts[:'before'].nil?
      query_params[:'after'] = opts[:'after'] if !opts[:'after'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'meta'] = opts[:'meta'] if !opts[:'meta'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PinResults'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.get_pins",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#get_pins\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get pin object
    # Get a pin object and its status
    # @param requestid [String] 
    # @param [Hash] opts the optional parameters
    # @return [PinStatus]
    def get_pins_requestid(requestid, opts = {})
      data, _status_code, _headers = get_pins_requestid_with_http_info(requestid, opts)
      data
    end

    # Get pin object
    # Get a pin object and its status
    # @param requestid [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PinStatus, Integer, Hash)>] PinStatus data, response status code and response headers
    def get_pins_requestid_with_http_info(requestid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.get_pins_requestid ...'
      end
      # verify the required parameter 'requestid' is set
      if @api_client.config.client_side_validation && requestid.nil?
        fail ArgumentError, "Missing the required parameter 'requestid' when calling Web3StorageHTTPAPIApi.get_pins_requestid"
      end
      # resource path
      local_var_path = '/pins/{requestid}'.sub('{' + 'requestid' + '}', CGI.escape(requestid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PinStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.get_pins_requestid",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#get_pins_requestid\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve information about an upload
    # Retrieve metadata about a specific file by using `/status/{cid}`, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
    # @param cid [String] 
    # @param [Hash] opts the optional parameters
    # @return [Status]
    def get_status_cid(cid, opts = {})
      data, _status_code, _headers = get_status_cid_with_http_info(cid, opts)
      data
    end

    # Retrieve information about an upload
    # Retrieve metadata about a specific file by using &#x60;/status/{cid}&#x60;, supplying the CID of the file you are interested in. This metadata includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data.
    # @param cid [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Status, Integer, Hash)>] Status data, response status code and response headers
    def get_status_cid_with_http_info(cid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.get_status_cid ...'
      end
      # verify the required parameter 'cid' is set
      if @api_client.config.client_side_validation && cid.nil?
        fail ArgumentError, "Missing the required parameter 'cid' when calling Web3StorageHTTPAPIApi.get_status_cid"
      end
      # resource path
      local_var_path = '/status/{cid}'.sub('{' + 'cid' + '}', CGI.escape(cid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.get_status_cid",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#get_status_cid\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List previous uploads
    # Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying `before` and `size` parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of `before` in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
    # @param [Hash] opts the optional parameters
    # @option opts [Time] :before Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date.
    # @option opts [Integer] :size Specifies the maximum number of uploads to return. (default to 25)
    # @return [Array<Status>]
    def get_user_uploads(opts = {})
      data, _status_code, _headers = get_user_uploads_with_http_info(opts)
      data
    end

    # List previous uploads
    # Lists all previous uploads for the account ordered by creation date, newest first. These results can be paginated by specifying &#x60;before&#x60; and &#x60;size&#x60; parameters in the query string, using the creation date associated with the oldest upload returned in each batch as the value of &#x60;before&#x60; in subsequent calls.  Note this endpoint returns all uploads for the account not just the API key in use.  The information returned includes the creation date and file size, as well as details about how the network is storing your data. Using this information, you can identify peers on the [IPFS (InterPlanetary File System)](https://ipfs.io) network that are pinning the data, and [Filecoin](https://filecoin.io) storage providers that have accepted deals to store the data. 
    # @param [Hash] opts the optional parameters
    # @option opts [Time] :before Specifies a date, in ISO 8601 format. Ensures that the call to &#x60;/list&#x60; will not return any results newer than the given date.
    # @option opts [Integer] :size Specifies the maximum number of uploads to return.
    # @return [Array<(Array<Status>, Integer, Hash)>] Array<Status> data, response status code and response headers
    def get_user_uploads_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.get_user_uploads ...'
      end
      if @api_client.config.client_side_validation && !opts[:'size'].nil? && opts[:'size'] > 1000
        fail ArgumentError, 'invalid value for "opts[:"size"]" when calling Web3StorageHTTPAPIApi.get_user_uploads, must be smaller than or equal to 1000.'
      end

      if @api_client.config.client_side_validation && !opts[:'size'].nil? && opts[:'size'] < 1
        fail ArgumentError, 'invalid value for "opts[:"size"]" when calling Web3StorageHTTPAPIApi.get_user_uploads, must be greater than or equal to 1.'
      end

      # resource path
      local_var_path = '/user/uploads'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'before'] = opts[:'before'] if !opts[:'before'].nil?
      query_params[:'size'] = opts[:'size'] if !opts[:'size'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Status>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.get_user_uploads",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#get_user_uploads\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve HTTP headers regarding a CAR
    # This method is useful for doing a dry run of a call to `/car/{cid}`. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
    # @param cid [String] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def head_car_cid(cid, opts = {})
      head_car_cid_with_http_info(cid, opts)
      nil
    end

    # Retrieve HTTP headers regarding a CAR
    # This method is useful for doing a dry run of a call to &#x60;/car/{cid}&#x60;. Because it only returns HTTP header information, it is far more lightweight and can be used to get only the metadata about the given CAR file without retrieving a whole payload in the body of the HTTP response. 
    # @param cid [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def head_car_cid_with_http_info(cid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.head_car_cid ...'
      end
      # verify the required parameter 'cid' is set
      if @api_client.config.client_side_validation && cid.nil?
        fail ArgumentError, "Missing the required parameter 'cid' when calling Web3StorageHTTPAPIApi.head_car_cid"
      end
      # resource path
      local_var_path = '/car/{cid}'.sub('{' + 'cid' + '}', CGI.escape(cid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.head_car_cid",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:HEAD, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#head_car_cid\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload a CAR
    # Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [`/upload`](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header `X-NAME`, but be sure to encode the filename first. For example `LICENSE–MIT` should be sent as `LICENSE%E2%80%93MIT`. 
    # @param body [File] 
    # @param [Hash] opts the optional parameters
    # @return [UploadResponse]
    def post_car(body, opts = {})
      data, _status_code, _headers = post_car_with_http_info(body, opts)
      data
    end

    # Upload a CAR
    # Upload a [CAR](https://ipld.io/specs/transport/car/) (Content Addressable aRchive) file and store the [IPFS DAG](https://docs.ipfs.io/concepts/merkle-dag/) (Directed Acyclic Graph) it contains.  See the [Working with Content Archives guide](https://docs.web3.storage/how-tos/work-with-car-files) for details on creating CARs and splitting them into chunks for upload using the [carbites JavaScript API](https://github.com/nftstorage/carbites), [command line tool](https://github.com/nftstorage/carbites-cli/), or [Go library](https://github.com/alanshaw/go-carbites).  Requests to this endpoint have a maximum payload size of 100MB but partial DAGs are supported, so multiple CAR files with the same root but with different sub-trees can be sent. This enables uploading of files that are bigger than the maximum payload size.  Note that only one CAR can be uploaded at a time, and only CAR files are accepted. This is in contrast to [&#x60;/upload&#x60;](#operation/post-upload), which can upload multiple files at once and accepts both CAR files and files from the client.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
    # @param body [File] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(UploadResponse, Integer, Hash)>] UploadResponse data, response status code and response headers
    def post_car_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.post_car ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling Web3StorageHTTPAPIApi.post_car"
      end
      # resource path
      local_var_path = '/car'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/car', 'application/octet-stream'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'UploadResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.post_car",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#post_car\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add pin object
    # Add a new pin object for the current access token
    # @param psa_pin [PSAPin] 
    # @param [Hash] opts the optional parameters
    # @return [PinStatus]
    def post_pins(psa_pin, opts = {})
      data, _status_code, _headers = post_pins_with_http_info(psa_pin, opts)
      data
    end

    # Add pin object
    # Add a new pin object for the current access token
    # @param psa_pin [PSAPin] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PinStatus, Integer, Hash)>] PinStatus data, response status code and response headers
    def post_pins_with_http_info(psa_pin, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.post_pins ...'
      end
      # verify the required parameter 'psa_pin' is set
      if @api_client.config.client_side_validation && psa_pin.nil?
        fail ArgumentError, "Missing the required parameter 'psa_pin' when calling Web3StorageHTTPAPIApi.post_pins"
      end
      # resource path
      local_var_path = '/pins'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(psa_pin)

      # return_type
      return_type = opts[:debug_return_type] || 'PinStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.post_pins",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#post_pins\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Replace pin object
    # Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
    # @param requestid [String] 
    # @param psa_pin [PSAPin] 
    # @param [Hash] opts the optional parameters
    # @return [PinStatus]
    def post_pins_requestid(requestid, psa_pin, opts = {})
      data, _status_code, _headers = post_pins_requestid_with_http_info(requestid, psa_pin, opts)
      data
    end

    # Replace pin object
    # Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
    # @param requestid [String] 
    # @param psa_pin [PSAPin] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PinStatus, Integer, Hash)>] PinStatus data, response status code and response headers
    def post_pins_requestid_with_http_info(requestid, psa_pin, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.post_pins_requestid ...'
      end
      # verify the required parameter 'requestid' is set
      if @api_client.config.client_side_validation && requestid.nil?
        fail ArgumentError, "Missing the required parameter 'requestid' when calling Web3StorageHTTPAPIApi.post_pins_requestid"
      end
      # verify the required parameter 'psa_pin' is set
      if @api_client.config.client_side_validation && psa_pin.nil?
        fail ArgumentError, "Missing the required parameter 'psa_pin' when calling Web3StorageHTTPAPIApi.post_pins_requestid"
      end
      # resource path
      local_var_path = '/pins/{requestid}'.sub('{' + 'requestid' + '}', CGI.escape(requestid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(psa_pin)

      # return_type
      return_type = opts[:debug_return_type] || 'PinStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.post_pins_requestid",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#post_pins_requestid\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload and store one or more files
    # Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as `FormData` with `Content-Disposition` headers for each part to specify filenames and the request header `Content-Type: multipart/form-data`  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the `/car` endpoint.  You can also provide a name for the file using the header `X-NAME`, but be sure to encode the filename first. For example `LICENSE–MIT` should be sent as `LICENSE%E2%80%93MIT`. 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<File>] :file 
    # @return [UploadResponse]
    def post_upload(opts = {})
      data, _status_code, _headers = post_upload_with_http_info(opts)
      data
    end

    # Upload and store one or more files
    # Store files using Web3.Storage. You can upload either a single file or multiple files.  Send the POST request with one of the following: - a single file, with a single blob/file object as the body - multiple files, as &#x60;FormData&#x60; with &#x60;Content-Disposition&#x60; headers for each part to specify filenames and the request header &#x60;Content-Type: multipart/form-data&#x60;  Requests to this endpoint have a maximum payload size of 100MB. To upload larger files, see the documentation for the &#x60;/car&#x60; endpoint.  You can also provide a name for the file using the header &#x60;X-NAME&#x60;, but be sure to encode the filename first. For example &#x60;LICENSE–MIT&#x60; should be sent as &#x60;LICENSE%E2%80%93MIT&#x60;. 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<File>] :file 
    # @return [Array<(UploadResponse, Integer, Hash)>] UploadResponse data, response status code and response headers
    def post_upload_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: Web3StorageHTTPAPIApi.post_upload ...'
      end
      # resource path
      local_var_path = '/upload'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['file'] = @api_client.build_collection_param(opts[:'file'], :csv) if !opts[:'file'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'UploadResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"Web3StorageHTTPAPIApi.post_upload",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: Web3StorageHTTPAPIApi#post_upload\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
